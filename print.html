<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rust Edition Guide</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li><a href="editions/index.html"><strong aria-hidden="true">1.</strong> What are Editions?</a></li><li><ol class="section"><li><a href="editions/transitioning.html"><strong aria-hidden="true">1.1.</strong> Transitioning your code to a new edition</a></li></ol></li><li><a href="2015/index.html"><strong aria-hidden="true">2.</strong> Rust 2015</a></li><li><a href="2018/index.html"><strong aria-hidden="true">3.</strong> Rust 2018</a></li><li><ol class="section"><li><a href="2018/status.html"><strong aria-hidden="true">3.1.</strong> Feature status</a></li><li><a href="2018/transitioning/to-rust-2018.html"><strong aria-hidden="true">3.2.</strong> Transitioning to Rust 2018</a></li><li><ol class="section"><li><a href="2018/transitioning/traits/index.html"><strong aria-hidden="true">3.2.1.</strong> Trait system</a></li><li><ol class="section"><li><a href="2018/transitioning/traits/dyn-trait.html"><strong aria-hidden="true">3.2.1.1.</strong> dyn Trait</a></li><li><a href="2018/transitioning/traits/impl-trait.html"><strong aria-hidden="true">3.2.1.2.</strong> impl Trait</a></li></ol></li><li><a href="2018/transitioning/modules/index.html"><strong aria-hidden="true">3.2.2.</strong> Module system</a></li><li><ol class="section"><li><a href="2018/transitioning/modules/path-clarity.html"><strong aria-hidden="true">3.2.2.1.</strong> Path clarity</a></li><li><a href="2018/transitioning/modules/macros.html"><strong aria-hidden="true">3.2.2.2.</strong> Macro changes</a></li></ol></li><li><a href="2018/transitioning/concurrency/index.html"><strong aria-hidden="true">3.2.3.</strong> Concurrency additions</a></li><li><ol class="section"><li><a href="2018/transitioning/concurrency/async-await.html"><strong aria-hidden="true">3.2.3.1.</strong> async/await</a></li></ol></li><li><a href="2018/transitioning/ownership-and-lifetimes/index.html"><strong aria-hidden="true">3.2.4.</strong> Ownership and lifetimes</a></li><li><ol class="section"><li><a href="2018/transitioning/ownership-and-lifetimes/anonymous-lifetime.html"><strong aria-hidden="true">3.2.4.1.</strong> '_, the anonymous lifetime</a></li><li><a href="2018/transitioning/ownership-and-lifetimes/in-band-lifetimes.html"><strong aria-hidden="true">3.2.4.2.</strong> In-band lifetimes</a></li><li><a href="2018/transitioning/ownership-and-lifetimes/default-match-bindings.html"><strong aria-hidden="true">3.2.4.3.</strong> Default match bindings</a></li><li><a href="2018/transitioning/ownership-and-lifetimes/lifetime-elision-in-impl.html"><strong aria-hidden="true">3.2.4.4.</strong> Lifetime elision in impl</a></li><li><a href="2018/transitioning/ownership-and-lifetimes/struct-inference.html"><strong aria-hidden="true">3.2.4.5.</strong> T: 'a inference in structs</a></li></ol></li><li><a href="2018/transitioning/slice-patterns.html"><strong aria-hidden="true">3.2.5.</strong> Slice patterns</a></li><li><a href="2018/transitioning/errors/index.html"><strong aria-hidden="true">3.2.6.</strong> Error Handling</a></li><li><ol class="section"><li><a href="2018/transitioning/errors/question-mark.html"><strong aria-hidden="true">3.2.6.1.</strong> ? in fn main() and #[test]s</a></li></ol></li><li><a href="2018/transitioning/raw-identifiers.html"><strong aria-hidden="true">3.2.7.</strong> Raw identifiers</a></li></ol></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Rust Edition Guide</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#introduction" id="introduction"><h1>Introduction</h1></a>
<p>Welcome to the Rust Edition Guide! &quot;Editions&quot; are Rust's way of communicating
large changes in the way that it feels to write Rust code.</p>
<p>In this guide, we'll discuss:</p>
<ul>
<li>What editions are</li>
<li>What each edition is about</li>
<li>How to migrate your code from one edition to another</li>
</ul>
<p>Read on for more!</p>
<a class="header" href="print.html#what-are-editions" id="what-are-editions"><h1>What are Editions?</h1></a>
<p>Rust ships releases on a six-week cycle. This means that users get a constant
stream of new features. This is much faster than updates for other languages,
but this also means that each update is smaller.  After a while, all of those
tiny changes add up. But, from release to release, it can be hard to look back
and say <em>&quot;Wow, between Rust 1.10 and Rust 1.20, Rust has changed a lot!&quot;</em></p>
<p>Every two or three years, we'll be producing a new <em>edition</em> of Rust. Each
edition brings together the features that have landed into a clear package, with
fully updated documentation and tooling. New editions ship through the usual
release process.</p>
<p>This serves different purposes for different people:</p>
<ul>
<li>
<p>For active Rust users, it brings together incremental changes into an
easy-to-understand package.</p>
</li>
<li>
<p>For non-users, it signals that some major advancements have landed, which
might make Rust worth another look.</p>
</li>
<li>
<p>For those developing Rust itself, it provides a rallying point for the project as a
whole.</p>
</li>
</ul>
<a class="header" href="print.html#compatibility" id="compatibility"><h2>Compatibility</h2></a>
<p>When a new edition becomes available in the compiler, crates must explicitly opt
in to it to take full advantage. This opt in enables editions to contain
incompatible changes, like adding a new keyword that might conflict with
identifiers in code, or turning warnings into errors. The Rust compiler can link
crates of any editions together. Edition changes only affect the way the
compiler initially parses the code. Therefore, if you're using Rust 2015, and
one of your dependencies uses Rust 2018, it all works just fine. The opposite
situation works as well.</p>
<p>Just to be clear: most features will be available on all editions.
People using any edition of Rust will continue to see improvements as new
stable releases are made.  In some cases however, mainly when new keywords are
added, but sometimes for other reasons, there may be new features that are only
available in later editions.  You only need to upgrade if you want to take
advantage of such features.</p>
<a class="header" href="print.html#trying-out-the-2018-edition" id="trying-out-the-2018-edition"><h2>Trying out the 2018 edition</h2></a>
<p>At the time of writing, there are two editions: 2015 and 2018. 2015 is today's
Rust; Rust 2018 will ship later this year. To transition to the 2018 edition
from the 2015 edition, you'll want to get started with the <a href="editions/transitioning.html">transition
guide</a>.</p>
<a class="header" href="print.html#transitioning-your-code-to-a-new-edition" id="transitioning-your-code-to-a-new-edition"><h1>Transitioning your code to a new edition</h1></a>
<p>New editions might change the way you write Rust -- they add new syntax,
language, and library features but also remove features. For example,
<code>async</code>/<code>await</code> are keywords in Rust 2018, but not Rust 2015. Despite this
it's our intention that the migration to new editions is as smooth an experience
as possible. It's considered a bug if it's difficult to upgrade your crate to a
new edition. If you have a difficult time then a bug should be filed with Rust
itself.</p>
<p>Transitioning between editions is built around compiler lints. Fundamentally,
the process works like this:</p>
<ul>
<li>Turn on lints to indicate where code is incompatible with a new edition</li>
<li>Get your code compiling with no warnings.</li>
<li>Opt in to the new edition, the code should compile.</li>
<li>Optionally, enable lints about <em>idiomatic</em> code in the new edition.</li>
</ul>
<p>Luckily, we've been working on Cargo to help assist with this process,
culminating in a new built-in subcommand <code>cargo fix</code>. It can take suggestions
from the compiler and automatically re-write your code to comply with new
features and idioms, drastically reducing the number of warnings you need to fix
manually!</p>
<blockquote>
<p><code>cargo fix</code> is still quite young, and very much a work in development. But it
works for the basics! We're working hard on making it better and more robust,
but please bear with us for now.</p>
</blockquote>
<a class="header" href="print.html#the-preview-period" id="the-preview-period"><h2>The preview period</h2></a>
<p>First, editions have a &quot;preview&quot; phase. This lets you try out the new edition
in nightly Rust. During the preview, there's an extra step you need to take
to opt in. At the time of writing, Rust 2018 is in its preview phase.</p>
<p>To do that, add this feature flag to your <code>lib.rs</code> or <code>main.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(rust_2018_preview)]
#fn main() {
#}</code></pre></pre>
<p>This will ensure that you're enabling all of the relevant features. Note that
during the time the preview is available, we may continue to add/enable new
features with this flag!</p>
<a class="header" href="print.html#fix-edition-compatibility-warnings" id="fix-edition-compatibility-warnings"><h2>Fix edition compatibility warnings</h2></a>
<p>Next up is to enable compiler warnings about code which is incompatible with the
new 2018 edition. This is where the handy <code>cargo fix</code> tool comes into the
picture. To enable the compatibility lints for your project you run:</p>
<pre><code class="language-shell">$ cargo +nightly fix --prepare-for 2018 --all-targets --all-features
</code></pre>
<p>This will instruct Cargo to compile all targets in your project (libraries,
binaries, tests, etc.) while enabling all Cargo features and prepare them for
the 2018 edition. Cargo will likely automatically fix a number of files,
informing you as it goes along.</p>
<p>If Cargo can't automatically fix everything it'll print out the remaining
warnings. Continue to run the above command until all warnings have been solved.</p>
<p>You can explore more about the <code>cargo fix</code> command with:</p>
<pre><code class="language-shell">$ cargo +nightly fix --help
</code></pre>
<a class="header" href="print.html#commit-to-the-next-edition" id="commit-to-the-next-edition"><h2>Commit to the next edition</h2></a>
<p>Once you're happy with those changes, it's time to use the new edition.
Add this to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">cargo-features = [&quot;edition&quot;]

[package]
edition = '2018'
</code></pre>
<p>That <code>cargo-features</code> line should go at the very top; and <code>edition</code> goes into
the <code>[package]</code> section. As mentioned above, right now this is a nightly-only
feature of Cargo, so you need to enable it for things to work.</p>
<p>At this point, your project should compile with a regular old <code>cargo +nightly build</code>. If it does not, this is a bug! Please <a href="https://github.com/rust-lang/rust/issues/new">file an issue</a>.</p>
<a class="header" href="print.html#writing-idiomatic-code-in-a-new-edition" id="writing-idiomatic-code-in-a-new-edition"><h2>Writing idiomatic code in a new edition</h2></a>
<p>Your crate has now entered the 2018 edition of Rust, congrats! Recall though
that Editions in Rust signify a shift in idioms over time. While much old
code will continue to compile it might be written with different idioms today.</p>
<p>An optional next step you can take is to update your code to be idiomatic within
the new edition. This is done with a different set of &quot;idiom lints&quot;. To enable
these lints add this to your <code>lib.rs</code> or <code>main.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![warn(rust_2018_idioms)]
#fn main() {
#}</code></pre></pre>
<p>and then execute:</p>
<pre><code class="language-shell">$ cargo +nightly fix
</code></pre>
<p>As before Cargo will automatically fix as much as it can, but you may also need
to fix some warnings manually. Once all warnings have been solved you're not
only compiling with the 2018 edition but you're also already writing idiomatic
2018 code!</p>
<a class="header" href="print.html#rust-2015" id="rust-2015"><h1>Rust 2015</h1></a>
<p>Rust 2015 has a theme of &quot;stability&quot;. It commenced with the release of 1.0,
and is the &quot;default edition&quot;. The edition system was conceived in late 2017,
but Rust 1.0 was released in May of 2015. As such, 2015 is the edition
that you get when you don't specify any particular edition, for backwards
compatibility reasons.</p>
<p>&quot;Stability&quot; is the theme of Rust 2015 because 1.0 marked a huge change in
Rust development. Previous to Rust 1.0, Rust was changing on a daily basis.
This made it very difficult to write large software in Rust, and made it
difficult to learn. With the release of Rust 1.0 and Rust 2015, we committed
to backwards compatibility, ensuring a solid foundation for people to build
projects on top of.</p>
<p>Since it's the default edition, there's no way to port your code to Rust
2015; it just <em>is</em>. You'll be transitioning <em>away</em> from 2015, but never
really <em>to</em> 2015. As such, there's not much else to say about it!</p>
<a class="header" href="print.html#rust-2018" id="rust-2018"><h1>Rust 2018</h1></a>
<p>The edition system was created for the release of Rust 2018. The theme of Rust 2018
is <em>productivity</em>. Rust 2018 improves upon Rust 2015 through new features,
simpler syntax in some cases, a smarter borrow-checker, and a host of other things.
These are all in service of the productivity goal. Rust 2015 was a foundation;
Rust 2018 smooths off rough edges, makes writing code simpler and easier,
and removes some inconsistencies.</p>
<a class="header" href="print.html#rust-2018-feature-status" id="rust-2018-feature-status"><h1>Rust 2018 Feature Status</h1></a>
<a class="header" href="print.html#language" id="language"><h2>Language</h2></a>
<table><thead><tr><th> <strong>Feature</strong> </th><th> <strong>Status</strong> </th><th> <strong>Minimum Edition</strong> </th></tr></thead><tbody>
<tr><td> <a href="https://rust-lang-nursery.github.io/edition-guide/2018/transitioning/traits/impl-trait.html"><code>impl Trait</code></a> </td><td> <a href="https://blog.rust-lang.org/2018/05/10/Rust-1.26.html">Shipped, 1.26</a> </td><td> 2015 </td></tr>
<tr><td> <a href="https://rust-lang-nursery.github.io/edition-guide/2018/transitioning/slice-patterns.html">Basic slice patterns</a> </td><td> <a href="https://blog.rust-lang.org/2018/05/10/Rust-1.26.html">Shipped, 1.26</a> </td><td> 2015 </td></tr>
<tr><td> <a href="https://rust-lang-nursery.github.io/edition-guide/2018/transitioning/ownership-and-lifetimes/default-match-bindings.html">Default match bindings</a> </td><td> <a href="https://blog.rust-lang.org/2018/05/10/Rust-1.26.html">Shipped, 1.26</a> </td><td> 2015 </td></tr>
<tr><td> <a href="https://rust-lang-nursery.github.io/edition-guide/2018/transitioning/ownership-and-lifetimes/anonymous-lifetime.html">Anonymous lifetimes</a> </td><td> <a href="https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1260-2018-05-10">Shipped, 1.26</a> </td><td> 2015 </td></tr>
<tr><td> <a href="https://rust-lang-nursery.github.io/edition-guide/2018/transitioning/traits/dyn-trait.html"><code>dyn Trait</code></a> </td><td> <a href="https://blog.rust-lang.org/2018/06/21/Rust-1.27.html">Shipped, 1.27</a> </td><td> 2015 </td></tr>
<tr><td> SIMD support </td><td> <a href="https://blog.rust-lang.org/2018/06/21/Rust-1.27.html">Shipped, 1.27</a> </td><td> 2015 </td></tr>
<tr><td> <a href="https://rust-lang-nursery.github.io/edition-guide/2018/transitioning/errors/question-mark.html"><code>?</code> in <code>main</code>/tests</a> </td><td> <a href="https://blog.rust-lang.org/2018/05/10/Rust-1.26.html">Shipping, 1.26</a> and 1.28 </td><td> 2015 </td></tr>
<tr><td> <a href="https://rust-lang-nursery.github.io/edition-guide/2018/transitioning/ownership-and-lifetimes/in-band-lifetimes.html">In-band lifetimes</a> </td><td> Unstable; <a href="https://github.com/rust-lang/rust/issues/44524">tracking issue</a> </td><td> 2015 </td></tr>
<tr><td> <a href="https://rust-lang-nursery.github.io/edition-guide/2018/transitioning/ownership-and-lifetimes/lifetime-elision-in-impl.html">Lifetime elision in <code>impl</code>s</a> </td><td> Unstable; <a href="https://github.com/rust-lang/rust/issues/44524">tracking issue</a> </td><td> 2015 </td></tr>
<tr><td> Non-lexical lifetimes </td><td> <a href="http://smallcultfollowing.com/babysteps/blog/2018/06/15/mir-based-borrow-check-nll-status-update/">Implemented but not ready for preview</a> </td><td> 2015 </td></tr>
<tr><td> <a href="https://rust-lang-nursery.github.io/edition-guide/2018/transitioning/ownership-and-lifetimes/struct-inference.html"><code>T: 'a</code> inference in <code>struct</code>s</a> </td><td> Unstable; <a href="https://github.com/rust-lang/rust/issues/44493">tracking issue</a> </td><td> 2015 </td></tr>
<tr><td> <a href="https://rust-lang-nursery.github.io/edition-guide/2018/transitioning/raw-identifiers.html">Raw identifiers</a> </td><td> Unstable; <a href="https://github.com/rust-lang/rust/issues/48589">tracking issue</a> </td><td> ? </td></tr>
<tr><td> <a href="https://rust-lang-nursery.github.io/edition-guide/2018/transitioning/modules/macros.html">Import macros via <code>use</code></a> </td><td> Unstable; <a href="https://github.com/rust-lang/rust/issues/35896">tracking issue</a> </td><td> ? </td></tr>
<tr><td> <a href="https://rust-lang-nursery.github.io/edition-guide/2018/transitioning/modules/path-clarity.html">Module system path changes</a> </td><td> Unstable; <a href="https://github.com/rust-lang/rust/issues/44660">tracking issue</a> </td><td> 2018 </td></tr>
<tr><td> <a href="https://rust-lang-nursery.github.io/edition-guide/2018/transitioning/concurrency/async-await.html"><code>async</code>/<code>await</code></a> </td><td> <a href="https://github.com/rust-lang/rust/issues/50547">Not fully implemented</a> </td><td> 2018 </td></tr>
</tbody></table>
<a class="header" href="print.html#standard-library" id="standard-library"><h2>Standard library</h2></a>
<table><thead><tr><th> <strong>Feature</strong> </th><th> <strong>Status</strong> </th></tr></thead><tbody>
<tr><td> <a href="https://github.com/rust-lang/rust/issues/49668">Custom global allocators</a> </td><td> Will ship in 1.28 </td></tr>
</tbody></table>
<a class="header" href="print.html#tooling" id="tooling"><h2>Tooling</h2></a>
<table><thead><tr><th> <strong>Tool</strong> </th><th> <strong>Status</strong> </th></tr></thead><tbody>
<tr><td> <a href="https://github.com/rust-lang-nursery/rls">RLS</a> 1.0 </td><td> Feature-complete; see <a href="https://github.com/rust-lang-nursery/rls/milestone/7">1.0 milestone</a> </td></tr>
<tr><td> <a href="https://github.com/rust-lang-nursery/rustfmt">rustfmt</a> 1.0 </td><td> Finalizing spec; <a href="https://github.com/rust-lang-nursery/rustfmt/milestone/2">1.0 milestone</a>, <a href="https://github.com/rust-lang/rfcs/pull/2436">style guide RFC</a>, <a href="https://github.com/rust-lang/rfcs/pull/2437">stability RFC</a> </td></tr>
<tr><td> <a href="https://github.com/rust-lang-nursery/rust-clippy">Clippy</a> 1.0 </td><td> <a href="https://github.com/rust-lang/rfcs/pull/2476">RFC</a> </td></tr>
</tbody></table>
<a class="header" href="print.html#documentation" id="documentation"><h2>Documentation</h2></a>
<table><thead><tr><th> <strong>Tool</strong> </th><th> <strong>Status</strong> </th></tr></thead><tbody>
<tr><td> <a href="https://rust-lang-nursery.github.io/edition-guide/">Edition Guide</a> </td><td> Initial draft complete </td></tr>
<tr><td> <a href="https://github.com/rust-lang/book/">TRPL</a> </td><td> Updated as features stabilize </td></tr>
</tbody></table>
<a class="header" href="print.html#web-site" id="web-site"><h2>Web site</h2></a>
<p>The visual design is being finalized, and early rounds of content brainstorming are complete.</p>
<a class="header" href="print.html#transitioning-to-rust-2018" id="transitioning-to-rust-2018"><h1>Transitioning to Rust 2018</h1></a>
<p>There's a lot of new stuff in Rust 2018! This section will cover, bit by bit,
each new major feature of the edition, and how to move your code from Rust
2015 to Rust 2018.</p>
<a class="header" href="print.html#trait-system" id="trait-system"><h1>Trait system</h1></a>
<p>The trait system has received some nice upgrades in Rust 2018.
These come with two new syntactic forms: <code>impl Trait</code> and <code>dyn Trait</code>.
The former gives you new powers, the latter clarifies syntax for trait objects.</p>
<a class="header" href="print.html#dyn-trait" id="dyn-trait"><h1>dyn Trait</h1></a>
<p>The <code>dyn Trait</code> feature is the new syntax for using trait objects. In short:</p>
<ul>
<li><code>Box&lt;Trait&gt;</code> becomes <code>Box&lt;dyn Trait&gt;</code></li>
<li><code>&amp;Trait</code> and <code>&amp;mut Trait</code> become <code>&amp;dyn Trait</code> and <code>&amp;mut dyn Trait</code></li>
</ul>
<p>And so on. In code:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Trait {}

impl Trait for i32 {}

// old
fn function1() -&gt; Box&lt;Trait&gt; {
# unimplemented!()
}

// new
fn function2() -&gt; Box&lt;dyn Trait&gt; {
# unimplemented!()
}
#}</code></pre></pre>
<p>That's it!</p>
<a class="header" href="print.html#more-details" id="more-details"><h2>More details</h2></a>
<p>Using just the trait name for trait objects turned out to be a bad decision.
The current syntax is often ambiguous and confusing, even to veterans,
and favors a feature that is not more frequently used than its alternatives,
is sometimes slower, and often cannot be used at all when its alternatives can.</p>
<p>Furthermore, with <code>impl Trait</code> arriving, &quot;<code>impl Trait</code> vs <code>dyn Trait</code>&quot; is much
more symmetric, and therefore a bit nicer, than &quot;<code>impl Trait</code> vs <code>Trait</code>&quot;.
<code>impl Trait</code> is explained further in the next section.</p>
<p>In the new edition, you should therefore prefer <code>dyn Trait</code> to just <code>Trait</code>
where you need a trait object.</p>
<a class="header" href="print.html#impl-trait" id="impl-trait"><h1>impl Trait</h1></a>
<p><code>impl Trait</code> is the new way to specify unnamed but concrete types that implement a specific trait.
There are two places you can put it: argument position, and return position.</p>
<pre><code class="language-rust ignore">trait Trait {}

// argument position
fn foo(arg: impl Trait) {
}

// return position
fn foo() -&gt; impl Trait {
}
</code></pre>
<a class="header" href="print.html#argument-position" id="argument-position"><h2>Argument Position</h2></a>
<p>In argument position, this feature is quite simple. These two forms
are almost the same:</p>
<pre><code class="language-rust ignore">trait Trait {}

fn foo&lt;T: Trait&gt;(arg: T) {
}

fn foo(arg: impl Trait) {
}
</code></pre>
<p>That is, it's a slightly shorter syntax for a generic type parameter. It
means, &quot;<code>arg</code> is an argument that takes any type that implements the <code>Trait</code>
trait.&quot;</p>
<p>However, there's also an important technical difference between <code>T: Trait</code> and
<code>impl Trait</code> here. When you write the former, you can specify the type of <code>T</code>
at the call site with turbo-fish syntax as with <code>foo::&lt;usize&gt;(1)</code>.
In the case of <code>impl Trait</code>, if it is used anywhere in the function definition,
then you can't use turbo-fish at all. Therefore, you should be mindful that
changing both from and to <code>impl Trait</code> can constitute a breaking change for the
users of your code.</p>
<a class="header" href="print.html#return-position" id="return-position"><h2>Return Position</h2></a>
<p>In return position, this feature is more interesting. It means &quot;I am
returning some type that implements the <code>Trait</code> trait, but I'm not going
to tell you exactly what the type is.&quot; Before <code>impl Trait</code>, you could
do this with trait objects:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Trait {}

impl Trait for i32 {}

fn returns_a_trait_object() -&gt; Box&lt;dyn Trait&gt; {
    Box::new(5)
}
#}</code></pre></pre>
<p>However, this has some overhead: the <code>Box&lt;T&gt;</code> means that there's a heap
allocation here, and this will use dynamic dispatch. See the <a href="/2018/transitioning/traits/dyn-trait.html"><code>dyn Trait</code></a> section
for an explanation of this syntax. But we only ever return one possible thing
here, the <code>Box&lt;i32&gt;</code>. This means that we're paying for dynamic dispatch, even
though we don't use it!</p>
<p>With <code>impl Trait</code>, the code above could be written like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Trait {}

impl Trait for i32 {}

fn returns_a_trait_object() -&gt; impl Trait {
    5
}
#}</code></pre></pre>
<p>Here, we have no <code>Box&lt;T&gt;</code>, no trait object, and no dynamic dispatch. But
we still can obscure the <code>i32</code> return type.</p>
<p>With <code>i32</code>, this isn't super useful. But there's one major place in Rust
where this is much more useful: closures.</p>
<a class="header" href="print.html#impl-trait-and-closures" id="impl-trait-and-closures"><h3><code>impl Trait</code> and closures</h3></a>
<blockquote>
<p>If you need to catch up on closures, check out <a href="https://doc.rust-lang.org/book/second-edition/ch13-01-closures.html">their chapter in the
book</a>.</p>
</blockquote>
<p>In Rust, closures have a unique, un-writable type. They do implement the <code>Fn</code>
family of traits, however. This means that previously, the only way to return
a closure from a function was to use a trait object:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
#}</code></pre></pre>
<p>You couldn't write the type of the closure, only use the <code>Fn</code> trait. That means
that the trait object is necessary. However, with <code>impl Trait</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
    |x| x + 1
}
#}</code></pre></pre>
<p>We can now return closures by value, just like any other type!</p>
<a class="header" href="print.html#more-details-1" id="more-details-1"><h2>More details</h2></a>
<p>The above is all you need to know to get going with <code>impl Trait</code>, but for
some more nitty-gritty details: type parameters and <code>impl Trait</code> in argument
position are universals (universally quantified types). Meanwhile, <code>impl Trait</code>
in return position are existentials (existentially quantified types).
Okay, maybe that's a bit too jargon-heavy. Let's step back.</p>
<p>Consider this function:</p>
<pre><code class="language-rust ignore">fn foo&lt;T: Trait&gt;(x: T) {
</code></pre>
<p>When you call it, you set the type, <code>T</code>. &quot;you&quot; being the caller here. This
signature says &quot;I accept any type that implements Trait.&quot; (&quot;any type&quot; ==
universal in the jargon)</p>
<p>This version:</p>
<pre><code class="language-rust ignore">fn foo&lt;T: Trait&gt;() -&gt; T {
</code></pre>
<p>is similar, but also different. You, the caller, provide the type you want,
<code>T</code>, and then the function returns it. You can see this in Rust today with
things like parse or collect:</p>
<pre><code class="language-rust ignore">let x: i32 = &quot;5&quot;.parse()?;
let x: u64 = &quot;5&quot;.parse()?;
</code></pre>
<p>Here, <code>.parse</code> has this signature:</p>
<pre><code class="language-rust ignore">pub fn parse&lt;F&gt;(&amp;self) -&gt; Result&lt;F, &lt;F as FromStr&gt;::Err&gt; where
    F: FromStr,
</code></pre>
<p>Same general idea, though with a result type and <code>FromStr</code> has an associated
type... anyway, you can see how <code>F</code> is in the return position here. So you
have the ability to choose.</p>
<p>With <code>impl Trait</code>, you're saying &quot;hey, some type exists that implements this
trait, but I'm not gonna tell you what it is.&quot; (&quot;existential&quot; in the jargon,
&quot;some type exists&quot;). So now, the caller can't choose, and the function itself
gets to choose. If we tried to define parse with <code>Result&lt;impl F,...</code> as the
return type, it wouldn't work.</p>
<a class="header" href="print.html#using-impl-trait-in-more-places" id="using-impl-trait-in-more-places"><h3>Using <code>impl Trait</code> in more places</h3></a>
<p>As previously mentioned, as a start, you will only be able to use <code>impl Trait</code>
as the argument or return type of a free or inherent function. However,
<code>impl Trait</code> can't be used inside implementations of traits, nor can it be
used as the type of a let binding or inside a type alias. Some of these
restrictions will eventually be lifted. For more information, see the
<a href="https://github.com/rust-lang/rust/issues/34511">tracking issue on <code>impl Trait</code></a>.</p>
<a class="header" href="print.html#module-system" id="module-system"><h1>Module system</h1></a>
<p>The module system is one of the most confusing aspects of Rust 2015 for many
Rustaceans. Rust 2018 includes an overhaul of the module system. In the
words of the core team:</p>
<blockquote>
<p>In other words, while there are simple and consistent rules defining the
module system, their consequences can feel inconsistent, counterintuitive and
mysterious.</p>
</blockquote>
<p>Rust 2018's module system also consists of simple rules, but they fit
together in a much nicer way. We expect these changes to be one of the
favorites in this edition.</p>
<a class="header" href="print.html#path-clarity" id="path-clarity"><h1>Path clarity</h1></a>
<p>The module system is often one of the hardest things for people new to Rust. Everyone
has their own things that take time to master, of course, but there's a root
cause for why it's so confusing to many: while there are simple and
consistent rules defining the module system, their consequences can feel
inconsistent, counterintuitive and mysterious.</p>
<p>As such, the 2018 edition of Rust introduces a few new module system
features, but they end up <em>simplifying</em> the module system, to make it more
clear as to what is going on.</p>
<p>Here's a brief summary:</p>
<ul>
<li><code>extern crate</code> is no longer needed</li>
<li>Absolute paths begin with a crate name, where the keyword <code>crate</code>
refers to the current crate.</li>
<li>The <code>crate</code> keyword also acts as a visibility modifier, equivalent to today's <code>pub(crate)</code>.</li>
<li>A <code>foo.rs</code> and <code>foo/</code> subdirectory may coexist; <code>mod.rs</code> is no longer needed
when placing submodules in a subdirectory.</li>
</ul>
<p>These may seem like arbitrary new rules when put this way, but the mental
model is now significantly simplified overall. Read on for more details!</p>
<a class="header" href="print.html#more-details-2" id="more-details-2"><h2>More details</h2></a>
<p>Let's talk about each new feature in turn.</p>
<a class="header" href="print.html#no-more-extern-crate" id="no-more-extern-crate"><h3>No more <code>extern crate</code></h3></a>
<p>This one is quite straightforward: you no longer need to write <code>extern crate</code> to
import a crate into your project. Before:</p>
<pre><code class="language-rust ignore">// Rust 2015

extern crate futures;

mod submodule {
    use futures::Future;
}
</code></pre>
<p>After:</p>
<pre><code class="language-rust ignore">// Rust 2018

mod submodule {
    use futures::Future;
}
</code></pre>
<p>Now, to add a new crate to your project, you can add it to your <code>Cargo.toml</code>,
and then there is no step two. If you're not using Cargo, you already had to pass
<code>--extern</code> flags to give <code>rustc</code> the location of external crates, so you'd just
keep doing what you were doing there as well.</p>
<p>One other use for <code>extern crate</code> was to import macros; that's no longer needed.
Check <a href="2018/transitioning/modules/macros.html">the macro section</a> for more.</p>
<a class="header" href="print.html#absolute-paths-begin-with-crate-or-the-crate-name" id="absolute-paths-begin-with-crate-or-the-crate-name"><h3>Absolute paths begin with <code>crate</code> or the crate name</h3></a>
<p>In Rust 2018, paths in <code>use</code> statements <em>must</em> begin with one of:</p>
<ul>
<li>A crate name</li>
<li><code>crate</code> for the current crate's root</li>
<li><code>self</code> for the current module's root</li>
<li><code>super</code> for the current module's parent</li>
</ul>
<p>Code that looked like this:</p>
<pre><code class="language-rust ignore">// Rust 2015

extern crate futures;

use futures::Future;

mod foo {
    struct Bar;
}

use foo::Bar;
</code></pre>
<p>Now looks like this:</p>
<pre><code class="language-rust ignore">// Rust 2018

// 'futures' is the name of a crate
use futures::Future;

mod foo {
    struct Bar;
}

// 'crate' means the current crate
use crate::foo::Bar;
</code></pre>
<p>In addition, all of these path forms are available outside of <code>use</code> statements
as well, which eliminates many sources of confusion. Consider this code in Rust
2015:</p>
<pre><code class="language-rust ignore">// Rust 2015

extern crate futures;

mod submodule {
    // this works!
    use futures::Future;

    // so why doesn't this work?
    fn my_poll() -&gt; futures::Poll { ... }
}

fn main() {
    // this works
    let five = std::sync::Arc::new(5);
}

mod submodule {
    fn function() {
        // ... so why doesn't this work
        let five = std::sync::Arc::new(5);
    }
}
</code></pre>
<p>In the <code>futures</code> example, the <code>my_poll</code> function signature is incorrect, because <code>submodule</code>
contains no items named <code>futures</code>; that is, this path is considered relative. But because
<code>use</code> is absolute, <code>use futures::</code> works even though a lone <code>futures::</code> doesn't! With <code>std</code>
it can be even more confusing, as you never wrote the <code>extern crate std;</code> line at all. So
why does it work in <code>main</code> but not in a submodule? Same thing: it's a relative path because
it's not in a <code>use</code> declaration. <code>extern crate std;</code> is inserted at the crate root, so
it's fine in <code>main</code>, but it doesn't exist in the submodule at all.</p>
<p>Let's look at how this change affects things:</p>
<pre><code class="language-rust ignore">// Rust 2018

// no more `extern crate futures;`

mod submodule {
    // 'futures' is the name of a crate, so this is absolute and works
    use futures::Future;

    // 'futures' is the name of a crate, so this is absolute and works
    fn my_poll() -&gt; futures::Poll { ... }
}

fn main() {
    // 'std' is the name of a crate, so this is absolute and works
    let five = std::sync::Arc::new(5);
}

mod submodule {
    fn function() {
        // 'std' is the name of a crate, so this is absolute and works
        let five = std::sync::Arc::new(5);
    }
}
</code></pre>
<p>Much more straightforward.</p>
<p><strong>Note</strong>: an alternative syntax is also under consideration: writing <code>::some::Local</code> rather than <code>crate::some::Local</code>. If you have thoughts about this alternative, please leave a comment on <a href="https://github.com/rust-lang/rust/issues/44660">the tracking issue</a> or start a thread on the <a href="https://internals.rust-lang.org/c/edition-2018-feedback">edition feedback category</a>.</p>
<a class="header" href="print.html#the-crate-visibility-modifier" id="the-crate-visibility-modifier"><h3>The <code>crate</code> visibility modifier</h3></a>
<p>In Rust 2015, you can use <code>pub(crate)</code> to make something visible
to your entire crate, but not exported publicly:</p>
<pre><pre class="playpen"><code class="language-rust">mod foo {
    pub mod bar {
        pub(crate) struct Foo;
    }
}

use foo::bar::Foo;
# fn main() {}
</code></pre></pre>
<p>In Rust 2018, the <code>crate</code> keyword is a synonym for this:</p>
<pre><code class="language-rust ignore">mod foo {
    pub mod bar {
        crate struct Foo;
    }
}

use foo::bar::Foo;
#fn main() {}
</code></pre>
<p>This is a minor bit of syntax sugar, but makes using it feel much more
natural.</p>
<a class="header" href="print.html#no-more-modrs" id="no-more-modrs"><h3>No more <code>mod.rs</code></h3></a>
<p>In Rust 2015, if you have a submodule:</p>
<pre><code class="language-rust ignore">mod foo;
</code></pre>
<p>It can live in <code>foo.rs</code> or <code>foo/mod.rs</code>. If it has submodules of its own, it
<em>must</em> be <code>foo/mod.rs</code>. So a <code>bar</code> submodule of <code>foo</code> would live at
<code>foo/bar.rs</code>.</p>
<p>In Rust 2018, <code>mod.rs</code> is no longer needed. <code>foo.rs</code> can just be <code>foo.rs</code>,
and the submodule is still <code>foo/bar.rs</code>. This eliminates the special
name, and if you have a bunch of files open in your editor, you can clearly
see their names, instead of having a bunch of tabs named <code>mod.rs</code>.</p>
<a class="header" href="print.html#macro-changes" id="macro-changes"><h1>Macro changes</h1></a>
<p>In Rust 2018, you can import specific macros from external crates via <code>use</code>
statements, rather than the old <code>#[macro_use]</code> attribute.</p>
<p>For example, consider a <code>bar</code> crate that implements a <code>baz!</code> macro. In
<code>src/lib.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_export]
macro_rules! baz {
    () =&gt; ()
}
#}</code></pre></pre>
<p>In your crate, you would have written</p>
<pre><code class="language-rust ignore">// Rust 2015

#[macro_use]
extern crate bar;

fn main() {
    baz!();
}
</code></pre>
<p>Now, you write:</p>
<pre><code class="language-rust ignore">// Rust 2018
#![feature(rust_2018_preview, use_extern_macros)]

use bar::baz;

fn main() {
    baz!();
}
</code></pre>
<p>This moves <code>macro_rules</code> macros to be a bit closer to other kinds of items.</p>
<a class="header" href="print.html#more-details-3" id="more-details-3"><h2>More details</h2></a>
<p>This only works for macros defined in external crates.
For macros defined locally, <code>#[macro_use] mod foo;</code> is still required, as it was in Rust 2015.</p>
<a class="header" href="print.html#concurrency-additions" id="concurrency-additions"><h1>Concurrency additions</h1></a>
<p>While concurrency and parallelism has always been a strong suit of Rust, it
often requires a lot of boilerplate. In Rust 2018, two new keywords, <code>async</code>
and <code>await</code>, help you write code that appears sequential, but executes
concurrently.</p>
<a class="header" href="print.html#asyncawait" id="asyncawait"><h1>async/await</h1></a>
<p>Async/await has not been implemented in the compiler yet.</p>
<a class="header" href="print.html#more-details-4" id="more-details-4"><h2>More details</h2></a>
<p>Coming soon!</p>
<a class="header" href="print.html#ownership-and-lifetimes" id="ownership-and-lifetimes"><h1>Ownership and lifetimes</h1></a>
<p>Some of the largest changes in Rust 2018 are in ownership and lifetimes. Some
features are for your convenience, some make the borrow checker smarter, and
others reduce boilerplate.</p>
<a class="header" href="print.html#a_-the-anonymous-lifetime" id="a_-the-anonymous-lifetime"><h1><code>'_</code>, the anonymous lifetime</h1></a>
<p>Rust 2018 allows you to explicitly mark where a lifetime is elided, for types
where this elision might otherwise be unclear. To do this, you can use the
special lifetime <code>'_</code> much like you can explicitly mark that a type is inferred
with the syntax <code>let x: _ = ..;</code>.</p>
<p>Let's say, for whatever reason, that we have a simple wrapper around <code>&amp;'a str</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct StrWrap&lt;'a&gt;(&amp;'a str);
#}</code></pre></pre>
<p>In Rust 2015, you might have written:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Rust 2015

use std::fmt;

# struct StrWrap&lt;'a&gt;(&amp;'a str);

fn make_wrapper(string: &amp;str) -&gt; StrWrap {
    StrWrap(string)
}

impl&lt;'a&gt; fmt::Debug for StrWrap&lt;'a&gt; {
    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        fmt.write_str(self.0)
    }
}
#}</code></pre></pre>
<p>In Rust 2018, you can instead write:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(rust_2018_preview)]

#fn main() {
# use std::fmt;
# struct StrWrap&lt;'a&gt;(&amp;'a str);

// Rust 2018

fn make_wrapper(string: &amp;str) -&gt; StrWrap&lt;'_&gt; {
    StrWrap(string)
}

impl fmt::Debug for StrWrap&lt;'_&gt; {
    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        fmt.write_str(self.0)
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#more-details-5" id="more-details-5"><h2>More details</h2></a>
<p>In the Rust 2015 snippet above, we've used <code>-&gt; StrWrap</code>. However, unless you take
a look at the definition of <code>StrWrap</code>, it is not clear that the returned value
is actually borrowing something. Therefore, starting with Rust 2018, it is
deprecated to leave off the lifetime parameters for non-reference-types (types
other than <code>&amp;</code> and <code>&amp;mut</code>). Instead, where you previously wrote <code>-&gt; StrWrap</code>,
you should now write <code>-&gt; StrWrap&lt;'_&gt;</code>, making clear that borrowing is occurring.</p>
<p>What exactly does <code>'_</code> mean? It depends on the context!
In output contexts, as in the return type of <code>make_wrapper</code>,
it refers to a single lifetime for  all &quot;output&quot; locations.
In input contexts, a fresh lifetime is generated for each &quot;input location&quot;.
More concretely, to understand input contexts, consider the following example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Rust 2015

struct Foo&lt;'a, 'b: 'a&gt; {
    field: &amp;'a &amp;'b str,
}

impl&lt;'a, 'b: 'a&gt; Foo&lt;'a, 'b&gt; {
    // some methods...
}
#}</code></pre></pre>
<p>We can rewrite this as:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(rust_2018_preview)]

#fn main() {
# struct Foo&lt;'a, 'b: 'a&gt; {
#     field: &amp;'a &amp;'b str,
# }

// Rust 2018

impl Foo&lt;'_, '_&gt; {
    // some methods...
}
#}</code></pre></pre>
<p>This is the same, because for each <code>'_</code>, a fresh lifetime is generated.
Finally, the relationship <code>'a: 'b</code> which the struct requires must be upheld.</p>
<p>For more details, see the <a href="https://github.com/rust-lang/rust/issues/44524">tracking issue on In-band lifetime bindings</a>.</p>
<a class="header" href="print.html#in-band-lifetimes" id="in-band-lifetimes"><h1>In-band lifetimes</h1></a>
<p>When writing an <code>fn</code> declaration, if a lifetime appears that is not already in
scope, it is taken to be a new binding, i.e. treated as a parameter to the
function.</p>
<p>So, in Rust 2015, you'd write:</p>
<pre><code class="language-rust ignore">fn two_args&lt;'bar&gt;(foo: &amp;Foo, bar: &amp;'bar Bar) -&gt; &amp;'bar Baz
</code></pre>
<p>In Rust 2018, you'd write:</p>
<pre><code class="language-rust ignore">fn two_args(foo: &amp;Foo, bar: &amp;'bar Bar) -&gt; &amp;'bar Baz
</code></pre>
<p>In other words, you can drop the explicit lifetime parameter declaration, and
instead simply start using a new lifetime name to connect lifetimes together.</p>
<a class="header" href="print.html#default-match-bindings" id="default-match-bindings"><h1>Default match bindings</h1></a>
<p>Have you ever had a borrowed <code>Option&lt;T&gt;</code> and tried to match on it? You
probably wrote this:</p>
<pre><code class="language-rust ignore">let s: &amp;Option&lt;String&gt; = &amp;Some(&quot;hello&quot;.to_string());

match s {
    Some(s) =&gt; println!(&quot;s is: {}&quot;, s),
    _ =&gt; (),
};
</code></pre>
<p>In Rust 2015, this would fail to compile, and you would have to write the following instead:</p>
<pre><code class="language-rust ignore">// Rust 2015

let s: &amp;Option&lt;String&gt; = &amp;Some(&quot;hello&quot;.to_string());

match s {
    &amp;Some(ref s) =&gt; println!(&quot;s is: {}&quot;, s),
    _ =&gt; (),
};
</code></pre>
<p>Rust 2018, by contrast, will infer the <code>&amp;</code>s and <code>ref</code>s, and your original code will Just Work.</p>
<p>This affects not just <code>match</code>, but patterns everywhere, such as in <code>let</code> statements,
closure arguments, and <code>for</code> loops.</p>
<a class="header" href="print.html#more-details-6" id="more-details-6"><h2>More details</h2></a>
<p>The mental model of patterns has shifted a bit with this change, to bring it into
line with other aspects of the language. For example, when writing a <code>for</code> loop,
you can iterate over borrowed contents of a collection by borrowing the collection
itself:</p>
<pre><code class="language-rust ignore">let my_vec: Vec&lt;i32&gt; = vec![0, 1, 2];

for x in &amp;my_vec { ... }
</code></pre>
<p>The idea is that an <code>&amp;T</code> can be understood as a <em>borrowed view of <code>T</code></em>, and so
when you iterate, match, or otherwise destructure a <code>&amp;T</code> you get a borrowed view
of its internals as well.</p>
<p>More formally, patterns have a &quot;binding mode,&quot; which is either by value (<code>x</code>),
by reference (<code>ref x</code>), or by mutable reference (<code>ref mut x</code>).
In Rust 2015, <code>match</code> always started in by-value mode, and required you
to explicitly write <code>ref</code> or <code>ref mut</code> in patterns to switch to a borrowing
mode. In Rust 2018, the type of the value being matched informs the binding
mode, so that if you match against an <code>&amp;Option&lt;String&gt;</code> with a <code>Some</code> variant, you
are put into <code>ref</code> mode automatically, giving you a borrowed view of the
internal data. Similarly, <code>&amp;mut Option&lt;String&gt;</code> would give you a <code>ref mut</code> view.</p>
<a class="header" href="print.html#lifetime-elision-in-impl" id="lifetime-elision-in-impl"><h1>Lifetime elision in <code>impl</code></h1></a>
<p>When writing an <code>impl</code>, you can mention lifetimes without them being bound in
the argument list. This is similar to
<a href="/2018/transitioning/ownership-and-lifetimes/in-band-lifetimes.md">in-band-lifetimes</a>
but for <code>impl</code>s.</p>
<p>In Rust 2015:</p>
<pre><code class="language-rust ignore">impl&lt;'a&gt; Iterator for MyIter&lt;'a&gt; { ... }
impl&lt;'a, 'b&gt; SomeTrait&lt;'a&gt; for SomeType&lt;'a, 'b&gt; { ... }
</code></pre>
<p>In Rust 2018:</p>
<pre><code class="language-rust ignore">impl Iterator for MyIter&lt;'iter&gt; { ... }
impl SomeTrait&lt;'tcx&gt; for SomeType&lt;'tcx, 'gcx&gt; { ... }
</code></pre>
<a class="header" href="print.html#more-details-7" id="more-details-7"><h2>More details</h2></a>
<p>To show off how this combines with in-band lifetimes in methods/functions, in Rust 2015:</p>
<pre><code class="language-rust ignore">// Rust 2015

impl&lt;'a&gt; MyStruct&lt;'a&gt; {
    fn foo(&amp;self) -&gt; &amp;'a str

    // we have to use 'b here because it conflicts with the 'a above.
    // If this weren't part of an `impl`, we'd be using `'a`.
    fn bar&lt;'b&gt;(&amp;self, arg: &amp;'b str) -&gt; &amp;'b str
}
</code></pre>
<p>in Rust 2018:</p>
<pre><code class="language-rust ignore">// Rust 2018

// no need for the repetition of 'a
impl MyStruct&lt;'a&gt; {

    // this works just like before
    fn foo(&amp;self) -&gt; &amp;'a str

    // we can declare 'b inline here
    fn bar(&amp;self, arg: &amp;'b str) -&gt; &amp;'b str
}
</code></pre>
<a class="header" href="print.html#t-a-inference-in-structs" id="t-a-inference-in-structs"><h1><code>T: 'a</code> inference in structs</h1></a>
<p>An annotation in the form of <code>T: 'a</code>, where <code>T</code> is either a type or another
lifetime, is called an <em>&quot;outlives&quot;</em> requirement. Note that <em>&quot;outlives&quot;</em> also
implies <code>'a: 'a</code>.</p>
<p>One way in which edition 2018 helps you out in maintaining flow when writing
programs is by removing the need to explicitly annotate these <code>T: 'a</code> outlives
requirements in <code>struct</code> definitions. Instead, the requirements will be
inferred from the fields present in the definitions.</p>
<p>Consider the following <code>struct</code> definitions in Rust 2015:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Rust 2015

struct Ref&lt;'a, T: 'a&gt; {
    field: &amp;'a T
}

// or written with a `where` clause:

struct WhereRef&lt;'a, T&gt; where T: 'a {
    data: &amp;'a T
}

// with nested references:

struct RefRef&lt;'a, 'b: 'a, T: 'b&gt; {
    field: &amp;'a &amp;'b T,
}

// using an associated type:

struct ItemRef&lt;'a, T: Iterator&gt;
where
    T::Item: 'a
{
    field: &amp;'a T::Item
}
#}</code></pre></pre>
<p>In Rust 2018, since the requirements are inferred, you can instead write:</p>
<pre><code class="language-rust ignore">// Rust 2018

struct Ref&lt;'a, T&gt; {
    field: &amp;'a T
}

struct WhereRef&lt;'a, T&gt; {
    data: &amp;'a T
}

struct RefRef&lt;'a, 'b, T&gt; {
    field: &amp;'a &amp;'b T,
}

struct ItemRef&lt;'a, T: Iterator&gt; {
    field: &amp;'a T::Item
}
</code></pre>
<p>If you prefer to be more explicit in some cases, that is still possible.</p>
<a class="header" href="print.html#more-details-8" id="more-details-8"><h2>More details</h2></a>
<p>For more details, see <a href="https://github.com/rust-lang/rust/issues/44493">the tracking issue</a>
and <a href="https://github.com/rust-lang/rfcs/pull/2093">the RFC</a>.</p>
<a class="header" href="print.html#basic-slice-patterns" id="basic-slice-patterns"><h1>Basic slice patterns</h1></a>
<p>Have you ever tried to pattern match on the contents and structure of a slice?
Rust 2018 will let you do just that.</p>
<p>For example, say we want to accept a list of names and respond to that with a
greeting. With slice patterns, we can do that easy as pie with:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    greet(&amp;[]);
    // output: Bummer, there's no one here :(
    greet(&amp;[&quot;Alan&quot;]);
    // output: Hey, there Alan! You seem to be alone.
    greet(&amp;[&quot;Joan&quot;, &quot;Hugh&quot;]);
    // output: Hello, Joan and Hugh. Nice to see you are at least 2!
    greet(&amp;[&quot;John&quot;, &quot;Peter&quot;, &quot;Stewart&quot;]);
    // output: Hey everyone, we seem to be 3 here today.
}

fn greet(people: &amp;[&amp;str]) {
    match people {
        [] =&gt; println!(&quot;Bummer, there's no one here :(&quot;),
        [only_one] =&gt; println!(&quot;Hey, there {}! You seem to be alone.&quot;, only_one),
        [first, second] =&gt; println!(
            &quot;Hello, {} and {}. Nice to see you are at least 2!&quot;,
            first, second
        ),
        _ =&gt; println!(&quot;Hey everyone, we seem to be {} here today.&quot;, people.len()),
    }
}
</code></pre></pre>
<p>Now, you don't have to check the length first.</p>
<p>We can also match on arrays like so:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let arr = [1, 2, 3];

assert_eq!(&quot;ends with 3&quot;, match arr {
    [_, _, 3] =&gt; &quot;ends with 3&quot;,
    [a, b, c] =&gt; &quot;ends with something else&quot;,
});
#}</code></pre></pre>
<a class="header" href="print.html#more-details-9" id="more-details-9"><h2>More details</h2></a>
<a class="header" href="print.html#exhaustive-patterns" id="exhaustive-patterns"><h3>Exhaustive patterns</h3></a>
<p>In the first example, note in particular the <code>_ =&gt; ...</code> pattern.
Since we are matching on a slice, it could be of any length, so we need a
<em>&quot;catch all pattern&quot;</em> to handle it. If we forgot the <code>_ =&gt; ...</code> or
<code>identifier =&gt; ...</code> pattern, we would instead get an error saying:</p>
<pre><code class="language-ignore">error[E0004]: non-exhaustive patterns: `&amp;[_, _, _]` not covered
</code></pre>
<p>If we added a case for a slice of size <code>3</code> we would instead get:</p>
<pre><code class="language-ignore">error[E0004]: non-exhaustive patterns: `&amp;[_, _, _, _]` not covered
</code></pre>
<p>and so on...</p>
<a class="header" href="print.html#arrays-and-exact-lengths" id="arrays-and-exact-lengths"><h3>Arrays and exact lengths</h3></a>
<p>In the second example above, since arrays in Rust are of known lengths,
we have to match on exactly three elements.
If we try to match on 2 or 4 elements,we get the errors:</p>
<pre><code class="language-ignore">error[E0527]: pattern requires 2 elements but array has 3
</code></pre>
<p>and</p>
<pre><code class="language-ignore">error[E0527]: pattern requires 4 elements but array has 3
</code></pre>
<a class="header" href="print.html#in-the-pipeline" id="in-the-pipeline"><h3>In the pipeline</h3></a>
<p>When it comes to slice patterns, more advanced forms are planned but
have not been stabilized yet. To learn more, follow <a href="https://github.com/rust-lang/rust/issues/23121">the tracking issue</a>.</p>
<a class="header" href="print.html#error-handling" id="error-handling"><h1>Error Handling</h1></a>
<p>Rust 2015 evolved its error handling story over time, from <code>try!</code> to <code>?</code>.
Rust 2018 continues this evolution, allowing you to use <code>?</code> in more places,
and adding even more convenient syntactic forms.</p>
<a class="header" href="print.html#a-in-fn-main-and-tests" id="a-in-fn-main-and-tests"><h1><code>?</code> in <code>fn main()</code> and <code>#[test]</code>s</h1></a>
<p>Rust's error handling revolves around returning <code>Result</code> and using
<code>?</code> to propagate errors. For those who write many small programs and, hopefully,
many tests, one common paper cut has been mixing entry points such as <code>main</code>
and <code>#[test]</code>s with error handling.</p>
<p>As an example, you might have tried to write:</p>
<pre><code class="language-rust ignore">use std::fs::File;

fn main() {
    let f = File::open(&quot;bar.txt&quot;)?;
}
</code></pre>
<p>Since <code>?</code> works by propagating the <code>Result</code> with an early return to the
enclosing function, the snippet above does not work, and results today
in the following error:</p>
<pre><code class="language-rust ignore">error[E0277]: the `?` operator can only be used in a function that returns `Result`
              or `Option` (or another type that implements `std::ops::Try`)
 --&gt; src/main.rs:5:13
  |
5 |     let f = File::open(&quot;bar.txt&quot;)?;
  |             ^^^^^^^^^^^^^^^^^^^^^^ cannot use the `?` operator in a function that returns `()`
  |
  = help: the trait `std::ops::Try` is not implemented for `()`
  = note: required by `std::ops::Try::from_error`
</code></pre>
<p>To solve this problem in Rust 2015, you might have written something like:</p>
<pre><pre class="playpen"><code class="language-rust">// Rust 2015

# use std::process;
# use std::error::Error;

fn run() -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    // real logic..
    Ok(())
}

fn main() {
    if let Err(e) = run() {
        println!(&quot;Application error: {}&quot;, e);
        process::exit(1);
    }
}
</code></pre></pre>
<p>However, in this case, the <code>run</code> function has all the interesting logic and
<code>main</code> is just boilerplate. The problem is even worse for <code>#[test]</code>s, since
there tend to be a lot more of them.</p>
<p>In Rust 2018 you can instead let your <code>#[test]</code>s and <code>main</code> functions return
a <code>Result</code>:</p>
<pre><pre class="playpen"><code class="language-rust no_run">// Rust 2018

use std::fs::File;

fn main() -&gt; Result&lt;(), std::io::Error&gt; {
    let f = File::open(&quot;bar.txt&quot;)?;

    Ok(())
}
</code></pre></pre>
<p>In this case, if say the file doesn't exist and there is an <code>Err(err)</code> somewhere,
then <code>main</code> will exit with an error code (not <code>0</code>) and print out a <code>Debug</code>
representation of <code>err</code>.</p>
<a class="header" href="print.html#more-details-10" id="more-details-10"><h2>More details</h2></a>
<p>Getting <code>-&gt; Result&lt;..&gt;</code> to work in the context of <code>main</code> and <code>#[test]</code>s is not
magic. It is all backed up by a <code>Termination</code> trait which all valid return
types of <code>main</code> and testing functions must implement. The trait is defined as:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Termination {
    fn report(self) -&gt; i32;
}
#}</code></pre></pre>
<p>When setting up the entry point for your application, the compiler will use this
trait and call <code>.report()</code> on the <code>Result</code> of the <code>main</code> function you have written.</p>
<p>Two simplified example implementations of this trait for <code>Result</code> and <code>()</code> are:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #![feature(process_exitcode_placeholder, termination_trait_lib)]
# use std::process::ExitCode;
# use std::fmt;
#
# pub trait Termination { fn report(self) -&gt; i32; }

impl Termination for () {
    fn report(self) -&gt; i32 {
        # use std::process::Termination;
        ExitCode::SUCCESS.report()
    }
}

impl&lt;E: fmt::Debug&gt; Termination for Result&lt;(), E&gt; {
    fn report(self) -&gt; i32 {
        match self {
            Ok(()) =&gt; ().report(),
            Err(err) =&gt; {
                eprintln!(&quot;Error: {:?}&quot;, err);
                # use std::process::Termination;
                ExitCode::FAILURE.report()
            }
        }
    }
}
#}</code></pre></pre>
<p>As you can see in the case of <code>()</code>, a success code is simply returned.
In the case of <code>Result</code>, the success case delegates to the implementation for
<code>()</code> but prints out an error message and a failure exit code on <code>Err(..)</code>.</p>
<p>To learn more about the finer details, consult either <a href="https://github.com/rust-lang/rust/issues/43301">the tracking issue</a> or <a href="https://github.com/rust-lang/rfcs/blob/master/text/1937-ques-in-main.md">the RFC</a>.</p>
<a class="header" href="print.html#raw-identifiers" id="raw-identifiers"><h1>Raw identifiers</h1></a>
<p>Rust, like many programming languages, has the concept of &quot;keywords&quot;.
These identifiers mean something to the language, and so you cannot use them in
places like variable names, function names, and other places.
Raw identifiers let you use keywords where they would not normally be allowed.</p>
<p>For example, <code>match</code> is a keyword. If you try to compile this function:</p>
<pre><code class="language-rust ignore">fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}
</code></pre>
<p>You'll get this error:</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<p>You can write this with a raw identifier:</p>
<pre><pre class="playpen"><code class="language-rust">#![feature(rust_2018_preview)]
#![feature(raw_identifiers)]

fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match(&quot;foo&quot;, &quot;foobar&quot;));
}
</code></pre></pre>
<p>Note the <code>r#</code> prefix on both the function name, as well as the call.</p>
<a class="header" href="print.html#more-details-11" id="more-details-11"><h2>More details</h2></a>
<p>This feature is useful for a few reasons, but the primary motivation was
inter-edition situations. For example, <code>try</code> is not a keyword in the 2015
edition, but is in the 2018 edition. So if you have a library that is written
in Rust 2015 and has a <code>try</code> function, to call it in Rust 2018, you'll need
to use the raw identifier.</p>
<a class="header" href="print.html#new-keywords" id="new-keywords"><h2>New keywords</h2></a>
<p>The new confirmed keywords in edition 2018 are:</p>
<a class="header" href="print.html#async-and-await" id="async-and-await"><h3><code>async</code> and <code>await</code></h3></a>
<p>Here, <code>async</code> is reserved for use in <code>async fn</code> as well as in <code>async ||</code> closures and
<code>async { .. }</code> blocks. Meanwhile, <code>await</code> is reserved to keep our options open
with respect to <code>await!(expr)</code> syntax. See <a href="https://github.com/rust-lang/rfcs/blob/master/text/2394-async_await.md#final-syntax-for-the-await-expression">RFC 2394</a> for more details.</p>
<a class="header" href="print.html#try" id="try"><h3><code>try</code></h3></a>
<p>The <code>do catch { .. }</code> blocks have been renamed to <code>try { .. }</code> and to support
that, the keyword <code>try</code> is reserved in edition 2018.
See <a href="https://github.com/rust-lang/rfcs/pull/2388">RFC 2388</a> for more details.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
